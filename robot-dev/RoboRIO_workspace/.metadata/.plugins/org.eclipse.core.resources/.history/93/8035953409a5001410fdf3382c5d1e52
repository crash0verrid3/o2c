#include <Navigator.Dev.h>

NAVIGATOR :: NAVIGATOR() :	INS_semaphore(0)

	{
	initcnt = 0;
	INS_Calibrating = false;
	pReadSensors = new Notifier(NAVIGATOR::CallReadSensors,this);
	pINSupdate = new Notifier(NAVIGATOR::CallUpdateINS,this);
	Navigation_Data_Queue_Depth = 0;
	Navigation_Data_Frame_Size = sizeof(Navigation_Data_Queue) / NAVIGATION_QUEUE_SIZE;
	Navigation_Data_Queue_Top = Navigation_Data_Queue_Bottom = 0;
	x_spin_rate = y_spin_rate = z_spin_rate = 0;
	sample_counter = 0;
	NavClockTime = 0;
	prevx = x_accel = y_accel = z_accel = 0;
	XspeedCenter = YspeedCenter = 0;
	temperature = 0;
	NavElapsedTime = NAVtemperature = NAVx_accel = NAVy_accel = NAVz_accel = 0;
	NAVx_spin = NAVy_spin = NAVz_spin = 0;

	Navigation_Status_Buffer.Xcoord = Navigation_Status_Buffer.Ycoord
									= Navigation_Status_Buffer.Xspeed
									= Navigation_Status_Buffer.Yspeed
									= Navigation_Status_Buffer.Xaccel
									= Navigation_Status_Buffer.Yaccel
									= Navigation_Status_Buffer.Timestamp = 0;
	#ifdef ANALOG_GYRO
		MyGyro = new AnalogInput(GYRO_ANALOGCHANNEL);
		cw_sensitivity = GYRO_CW_SENSITIVITY / 1000000000;		// Gyro is not consistent between clockwise turns and counter-clockwise turns
		ccw_sensitivity = GYRO_CCW_SENSITIVITY / 1000000000;	// Up to about 0.5 degrees per revolution difference between them
		GyroNoiseLimit = GYRO_NOISELIMIT;
		GyroCenter_X = GyroCenter_Y = GyroCenter_Z = GYRO_RATECENTER / 1000;
		accumulator = 0;
		prevaccum = 0;
		oversamplebits = 0;

		MyThermostat = new AnalogInput(THERMOSTAT_ANALOGCHANNEL);
	#endif
	#ifdef MPU3050_GYRO
		MyGyro = new I2C(I2C::kOnboard, GYRO_I2C_ADDR);	// locate the gyro on the I2C bus
		cw_sensitivity = GYRO_CW_SENSITIVITY / 1000000000;		// Gyro is not consistent between clockwise turns and counter-clockwise turns
		ccw_sensitivity = GYRO_CCW_SENSITIVITY / 1000000000;	// Up to about 0.5 degrees per revolution difference between them
		GyroNoiseLimit = GYRO_NOISELIMIT;
		GyroCenter_X = GyroCenter_Y = GyroCenter_Z = GYRO_RATECENTER / 1000;
	#endif
	#ifdef WPILIB_GYRO
		MyGyro = new Gyro(GYRO_ANALOGCHANNEL);
		cw_sensitivity = GYRO_CW_SENSITIVITY / 1000000000;		// Gyro is not consistent between clockwise turns and counter-clockwise turns
		ccw_sensitivity = GYRO_CCW_SENSITIVITY / 1000000000;	// Up to about 0.5 degrees per revolution difference between them
		GyroNoiseLimit = GYRO_NOISELIMIT;
		GyroCenter_X = GyroCenter_Y = GyroCenter_Z = GYRO_RATECENTER / 1000;

		MyThermostat = new AnalogInput(THERMOSTAT_ANALOGCHANNEL);
	#endif
	#ifdef ITG3200_GYRO
		MyGyro = new I2C(I2C::kOnboard, GYRO_I2C_ADDR);	// locate the gyro on the I2C bus
//		MyGyro = new I2C(I2C::kOnboard, GYRO_I2C_ALTADDR);	// locate the gyro on the I2C bus
		cw_sensitivity = GYRO_CW_SENSITIVITY / 1000000000;		// Gyro is not consistent between clockwise turns and counter-clockwise turns
		ccw_sensitivity = GYRO_CCW_SENSITIVITY / 1000000000;	// Up to about 0.5 degrees per revolution difference between them
		GyroNoiseLimit = GYRO_NOISELIMIT;
		GyroCenter_X = GyroCenter_Y = GyroCenter_Z = GYRO_RATECENTER / 1000;
	#endif
	#ifdef ADXL345_ACCEL
		MyAccel = new I2C(I2C::kOnboard, ACCEL_I2C_ADDR);	// locate the gyro on the I2C bus
//		MyAccel = new I2C(I2C::kOnboard, ACCEL_I2C_ALTADDR);	// locate the gyro on the I2C bus
		XaccelCenter = ACCEL_XCENTER / 1000;
		YaccelCenter = ACCEL_YCENTER / 1000;
		ZaccelCenter = ACCEL_ZCENTER / 1000;
	#endif
	#ifdef BUILTIN_ACCEL
		MyAccel = new BuiltInAccelerometer();
		XaccelCenter = ACCEL_XCENTER / 1000;
		YaccelCenter = ACCEL_YCENTER / 1000;
		ZaccelCenter = ACCEL_ZCENTER / 1000;
	#endif
	NavLoopCnt = 0;
	SampleElapsedTime = 0;
	SampleRunTime = 0;
	GyroInitCenter = GyroCenter_T = 0;
	GyroHeading = 0;	// actually want to read from SmartDashboard 'cause we might want to start the robot facing otherwise
	RobotDirection = 0;
	GyroTilt = false;
	noisyGyrocnt = 0;
	noisyAccelcnt = 0;
	gyro_accumulator_count = 0;
	dataNotRdyCnt = 0;
	prevcount = 0;
	SpinEffectCW = 0;
	SpinEffectCCW = 0;
	GyroSensitivity = (cw_sensitivity + ccw_sensitivity) / 2;
	Sensitivity_Offset = 0;		// we'll use this later to adjust sensitivity as a function of temperature (it does matter)
	thermo_sensitivity = 0;
	Xsensitivity = ACCEL_XSENSITIVITY;
	Ysensitivity = ACCEL_YSENSITIVITY;
	FrictionEffect = ACCEL_FRICTION;
	}


#ifdef MPU3050_GYRO
void NAVIGATOR :: InitMyGyro()
	{
	// Get the gyro configuration parameters from the SmartDashboard.
	int oversamplebits = SmartDashboard::GetNumber("OversampleBits",GYRO_OVERSAMPLEBITS);
	int avgbits = SmartDashboard::GetNumber("AvgBits",GYRO_SAMPLEAVGBITS);
	double samplerate = SmartDashboard::GetNumber("SampleRate",GYRO_SAMPLERATE);

	// Get the gyro tuning parameters from the SmartDashboard.
	GyroCenter_Z = GyroInitCenter = (SmartDashboard::GetNumber("GyroInitCenter",GYRO_RATECENTER) / 1000);
	GyroNoiseLimit = SmartDashboard::GetNumber("GyroNoiseLimit",GYRO_NOISELIMIT);
	// Did I mention that the gyro doesn't give the same
	// voltage shift / dps for clockwise and counter-clockwise.
	// In other words, the voltage shift does not appear to be entirely linear.
	// It's just a teeny, tiny bit off.
	cw_sensitivity = SmartDashboard::GetNumber("GyroSensitivityCW",GYRO_CW_SENSITIVITY) / 1000000000;
	ccw_sensitivity = SmartDashboard::GetNumber("GyroSensitivityCCW",GYRO_CCW_SENSITIVITY) / 1000000000;
	GyroSensitivity = (cw_sensitivity + ccw_sensitivity) / 2;
	// Did I mention that, if the gyro is not placed in the exact center of rotation
	// of the robot, then the above mentioned issue is further exagerated as speed
	// of rotation increases.
	SpinEffectCW = SmartDashboard::GetNumber("SpinEffectCW",GYRO_CW_SPIN_CORRECTION) / 1000000000000;
	SpinEffectCCW = SmartDashboard::GetNumber("SpinEffectCCW",GYRO_CCW_SPIN_CORRECTION) / 1000000000000;

	// Configure and initialize the gyro
	if (! MyGyro->AddressOnly())		// if the gyro is present, initialize its registers
		{
		initcnt++;
		if ((! MyGyro->Write(GYRO_Reg_Power, GYRO_H_Reset)))
			{
			Wait(1);
			if ((! MyGyro->Write((uint8_t) GYRO_Reg_PWR_MGM, (uint8_t) (GYRO_Stby_GX | GYRO_Stby_GY)))
					&& (! MyGyro->Write((uint8_t) GYRO_Reg_DLPF_FS, (uint8_t) (GYRO_1000dps | GYRO_1kHz)))
					&& (! MyGyro->Write((uint8_t) GYRO_Reg_SMPLRT_DIV, (uint8_t) GYRO_SampleDiv))
					&& (! MyGyro->Write((uint8_t) GYRO_Reg_INT_CFG, (uint8_t) (GYRO_DataRdy | GYRO_Latch | GYRO_AnyRd2Clr))))
					//&& (! MyGyro->Write((uint8_t) GYRO_Reg_ZoffsH, (uint8_t) ((int16_t) GYRO_RATECENTER >> 8)))
					//&& (! MyGyro->Write((uint8_t) GYRO_Reg_ZoffsL, (uint8_t) ((int16_t) GYRO_RATECENTER & 0xFF))))
					//	&& (! MyGyro->Write((uint8_t) GYRO_Reg_FIFOen, (uint8_t) GYRO_FIFO_GX | GYRO_FIFO_GZ | GYRO_FIFO_ft)))
				{
				initcnt++;
				}
			}
		}
	// If these parameters are not currently on the SmartDashboard, the values will default
	// to pre-programmed values.  Write out those values so the operator can change them to
	// whatever they want and then restart the RoboRIO User Program to pick up the new values.
	SmartDashboard::PutNumber("OversampleBits",oversamplebits);
	SmartDashboard::PutNumber("AvgBits",avgbits);
	SmartDashboard::PutNumber("SampleRate",samplerate);
	SmartDashboard::PutNumber("GyroInitCenter",GyroCenter_Z * 1000);
	SmartDashboard::PutNumber("GyroNoiseLimit",GyroNoiseLimit);
	SmartDashboard::PutNumber("GyroSensitivityCW",cw_sensitivity * 1000000000);
	SmartDashboard::PutNumber("GyroSensitivityCCW",ccw_sensitivity * 1000000000);
	SmartDashboard::PutNumber("SpinEffectCW",SpinEffectCW * 1000000000000);
	SmartDashboard::PutNumber("SpinEffectCCW",SpinEffectCCW * 1000000000000);
	}
#endif


#ifdef ITG3200_GYRO
void NAVIGATOR :: InitMyGyro()
	{
	// Get the gyro tuning parameters from the SmartDashboard.
	GyroCenter_Z = GyroInitCenter = (SmartDashboard::GetNumber("GyroInitCenter",GYRO_RATECENTER) / 1000);
	GyroNoiseLimit = SmartDashboard::GetNumber("GyroNoiseLimit",GYRO_NOISELIMIT);
	// Did I mention that the gyro doesn't give the same
	// voltage shift / dps for clockwise and counter-clockwise.
	// In other words, the voltage shift does not appear to be entirely linear.
	// It's just a teeny, tiny bit off.
	cw_sensitivity = SmartDashboard::GetNumber("GyroSensitivityCW",GYRO_CW_SENSITIVITY) / 1000000000;
	ccw_sensitivity = SmartDashboard::GetNumber("GyroSensitivityCCW",GYRO_CCW_SENSITIVITY) / 1000000000;
	GyroSensitivity = (cw_sensitivity + ccw_sensitivity) / 2;
	// Did I mention that, if the gyro is not placed in the exact center of rotation
	// of the robot, then the above mentioned issue is further exagerated as speed
	// of rotation increases.
	SpinEffectCW = SmartDashboard::GetNumber("SpinEffectCW",GYRO_CW_SPIN_CORRECTION) / 1000000000000;
	SpinEffectCCW = SmartDashboard::GetNumber("SpinEffectCCW",GYRO_CCW_SPIN_CORRECTION) / 1000000000000;

	// Configure and initialize the gyro
	if (! MyGyro->AddressOnly())		// if the gyro is present, initialize its registers
		{
		initcnt++;
//		if ((! MyGyro->Write(GYRO_Reg_PWR_MGM, GYRO_H_Reset)))
			{
			Wait(1);
			if ((! MyGyro->Write((uint8_t) GYRO_Reg_PWR_MGM, (uint8_t) GYRO_Clock_Z))
					&& (! MyGyro->Write((uint8_t) GYRO_Reg_DLPF_FS, (uint8_t) (GYRO_2000dps | GYRO_8kHz)))
					&& (! MyGyro->Write((uint8_t) GYRO_Reg_SMPLRT_DIV, (uint8_t) GYRO_5Samples))
					&& (! MyGyro->Write((uint8_t) GYRO_Reg_INT_CFG, (uint8_t) (GYRO_DataRdy | GYRO_Latch))))
//				&& (! MyGyro->Write((uint8_t) GYRO_Reg_SMPLRT_DIV, (uint8_t) GYRO_SampleDiv))
					//&& (! MyGyro->Write((uint8_t) GYRO_Reg_INT_CFG, (uint8_t) (GYRO_DataRdy | GYRO_Latch | GYRO_AnyRd2Clr))))
					//&& (! MyGyro->Write((uint8_t) GYRO_Reg_ZoffsH, (uint8_t) ((int16_t) GYRO_RATECENTER >> 8)))
					//&& (! MyGyro->Write((uint8_t) GYRO_Reg_ZoffsL, (uint8_t) ((int16_t) GYRO_RATECENTER & 0xFF))))
					//	&& (! MyGyro->Write((uint8_t) GYRO_Reg_FIFOen, (uint8_t) GYRO_FIFO_GX | GYRO_FIFO_GZ | GYRO_FIFO_ft)))
				{
				initcnt++;
				}
			}
		}
	// If these parameters are not currently on the SmartDashboard, the values will default
	// to pre-programmed values.  Write out those values so the operator can change them to
	// whatever they want and then restart the RoboRIO User Program to pick up the new values.
	SmartDashboard::PutNumber("GyroInitCenter",GyroCenter_Z * 1000);
	SmartDashboard::PutNumber("GyroNoiseLimit",GyroNoiseLimit);
	SmartDashboard::PutNumber("GyroSensitivityCW",cw_sensitivity * 1000000000);
	SmartDashboard::PutNumber("GyroSensitivityCCW",ccw_sensitivity * 1000000000);
	SmartDashboard::PutNumber("SpinEffectCW",SpinEffectCW * 1000000000000);
	SmartDashboard::PutNumber("SpinEffectCCW",SpinEffectCCW * 1000000000000);
	}
#endif

#ifdef ANALOG_GYRO
void NAVIGATOR :: InitMyGyro()
	{
	/*
	 * Note: There is a flaw in either the accumulator firmware or in the WPILib accumulator class.
	 * 		If you set any oversamplebits or average bits and then routinely call the ResetAccumulator method,
	 * 		several BAD things happen.  First, the ResetAccumulator method waits until the next oversampled/average
	 * 		data value is ready to be added to the accumulator.  Then, the accumulator is zeroed.  This means that
	 * 		the more oversamplebits and averagebits you set, the longer it takes for the ResetAccumulator method
	 * 		to complete.  Second, when it does complete, it throws out the data that was suppose to get added to
	 * 		the accumulator.
	 *
	 * 		So...if you want the hardware to do the heavy lifting (saving precious CPU cycles for other tasks)
	 * 		you cannot use the ResetAccumulator method between collecting datapoints.  You will actually lose more
	 * 		data than the oversampling and averaging functions were intended to preserve.
	 */
	// Get the gyro configuration parameters from the SmartDashboard.
	oversamplebits = SmartDashboard::GetNumber("OversampleBits",GYRO_OVERSAMPLEBITS);
	int avgbits = SmartDashboard::GetNumber("AvgBits",GYRO_SAMPLEAVGBITS);
	double samplerate = SmartDashboard::GetNumber("SampleRate",GYRO_SAMPLERATE);

	// Get the gyro tuning parameters from the SmartDashboard.
	GyroCenter_Z = GyroInitCenter = (SmartDashboard::GetNumber("GyroInitCenter",GYRO_RATECENTER) / 1000);
	GyroNoiseLimit = SmartDashboard::GetNumber("GyroNoiseLimit",GYRO_NOISELIMIT);
	// Did I mention that the gyro doesn't give the same
	// voltage shift / dps for clockwise and counter-clockwise.
	// In other words, the voltage shift does not appear to be entirely linear.
	// It's just a teeny, tiny bit off.
	cw_sensitivity = SmartDashboard::GetNumber("GyroSensitivityCW",GYRO_CW_SENSITIVITY) / 1000000000;
	ccw_sensitivity = SmartDashboard::GetNumber("GyroSensitivityCCW",GYRO_CCW_SENSITIVITY) / 1000000000;
	GyroSensitivity = (cw_sensitivity + ccw_sensitivity) / 2;
	// Did I mention that, if the gyro is not placed in the exact center of rotation
	// of the robot, then the above mentioned issue is further exagerated as speed
	// of rotation increases.
	SpinEffectCW = SmartDashboard::GetNumber("SpinEffectCW",GYRO_CW_SPIN_CORRECTION) / 1000000000000;
	SpinEffectCCW = SmartDashboard::GetNumber("SpinEffectCCW",GYRO_CCW_SPIN_CORRECTION) / 1000000000000;

	// Configure and initialize the gyro
	MyGyro->SetOversampleBits(oversamplebits);
	MyGyro->SetAverageBits(avgbits);
	MyGyro->SetSampleRate(samplerate);
	MyGyro->InitAccumulator();
	Wait (1);						// wait for the gyro to run its internal calibration sequence
	MyGyro->ResetAccumulator();		// then clear the garbage from the accumulator
	Wait (1);						// wait for the gyro to run its internal calibration sequence

	// If these parameters are not currently on the SmartDashboard, the values will default
	// to pre-programmed values.  Write out those values so the operator can change them to
	// whatever they want and then restart the RoboRIO User Program to pick up the new values.
	SmartDashboard::PutNumber("OversampleBits",oversamplebits);
	SmartDashboard::PutNumber("AvgBits",avgbits);
	SmartDashboard::PutNumber("SampleRate",samplerate);
	SmartDashboard::PutNumber("GyroInitCenter",GyroCenter_Z * 1000);
	SmartDashboard::PutNumber("GyroNoiseLimit",GyroNoiseLimit);
	SmartDashboard::PutNumber("GyroSensitivityCW",cw_sensitivity * 1000000000);
	SmartDashboard::PutNumber("GyroSensitivityCCW",ccw_sensitivity * 1000000000);
	SmartDashboard::PutNumber("SpinEffectCW",SpinEffectCW * 1000000000000);
	SmartDashboard::PutNumber("SpinEffectCCW",SpinEffectCCW * 1000000000000);
	}
#endif


#ifdef WPILIB_GYRO
void NAVIGATOR :: InitMyGyro()
	{
	// Get the gyro configuration parameters from the SmartDashboard.
	int oversamplebits = SmartDashboard::GetNumber("OversampleBits",GYRO_OVERSAMPLEBITS);
	int avgbits = SmartDashboard::GetNumber("AvgBits",GYRO_SAMPLEAVGBITS);
	double samplerate = SmartDashboard::GetNumber("SampleRate",GYRO_SAMPLERATE);

	// Get the gyro tuning parameters from the SmartDashboard.
	GyroCenter_Z = GyroInitCenter = (SmartDashboard::GetNumber("GyroInitCenter",GYRO_RATECENTER) / 1000);
	GyroNoiseLimit = SmartDashboard::GetNumber("GyroNoiseLimit",GYRO_NOISELIMIT);
	// Did I mention that the gyro doesn't give the same
	// voltage shift / dps for clockwise and counter-clockwise.
	// In other words, the voltage shift does not appear to be entirely linear.
	// It's just a teeny, tiny bit off.
	cw_sensitivity = SmartDashboard::GetNumber("GyroSensitivityCW",GYRO_CW_SENSITIVITY) / 1000000000;
	ccw_sensitivity = SmartDashboard::GetNumber("GyroSensitivityCCW",GYRO_CCW_SENSITIVITY) / 1000000000;
	GyroSensitivity = (cw_sensitivity + ccw_sensitivity) / 2;
	// Did I mention that, if the gyro is not placed in the exact center of rotation
	// of the robot, then the above mentioned issue is further exagerated as speed
	// of rotation increases.
	SpinEffectCW = SmartDashboard::GetNumber("SpinEffectCW",GYRO_CW_SPIN_CORRECTION) / 1000000000000;
	SpinEffectCCW = SmartDashboard::GetNumber("SpinEffectCCW",GYRO_CCW_SPIN_CORRECTION) / 1000000000000;

	// Configure and initialize the gyro
	// There are very limited configuration methods available (outside of the Tables)
	MyGyro->SetSensitivity((cw_sensitivity + ccw_sensitivity)/2);
	Wait (1);						// wait for the gyro to run its internal calibration sequence
	// If these parameters are not currently on the SmartDashboard, the values will default
	// to pre-programmed values.  Write out those values so the operator can change them to
	// whatever they want and then restart the RoboRIO User Program to pick up the new values.
	SmartDashboard::PutNumber("OversampleBits",oversamplebits);
	SmartDashboard::PutNumber("AvgBits",avgbits);
	SmartDashboard::PutNumber("SampleRate",samplerate);
	SmartDashboard::PutNumber("GyroInitCenter",GyroInitCenter * 1000);
	SmartDashboard::PutNumber("GyroNoiseLimit",GyroNoiseLimit);
	SmartDashboard::PutNumber("GyroSensitivityCW",cw_sensitivity * 1000000000);
	SmartDashboard::PutNumber("GyroSensitivityCCW",ccw_sensitivity * 1000000000);
	SmartDashboard::PutNumber("SpinEffectCW",SpinEffectCW * 1000000000000);
	SmartDashboard::PutNumber("SpinEffectCCW",SpinEffectCCW * 1000000000000);
	}
#endif


#ifdef ANALOG_GYRO
void NAVIGATOR :: InitMyThermostat()
	{
	// Get the thermostat configuration parameters from the SmartDashboard.
	// We will use the same configuration parameters as the gyro for consistent timing of data availability
	int oversamplebits = SmartDashboard::GetNumber("OversampleBits",GYRO_OVERSAMPLEBITS);
	int avgbits = SmartDashboard::GetNumber("AvgBits",GYRO_SAMPLEAVGBITS);
	double samplerate = SmartDashboard::GetNumber("SampleRate",GYRO_SAMPLERATE);
	// Configure and initialize the thermostat
	MyThermostat->SetOversampleBits(oversamplebits);
	MyThermostat->SetAverageBits(avgbits);
	MyThermostat->SetSampleRate(samplerate);
	// There are no thermostat tuning parameters
	}
#endif


#ifdef WPILIB_GYRO
void NAVIGATOR :: InitMyThermostat()
	{
	// Get the thermostat configuration parameters from the SmartDashboard.
	// We will use the same configuration parameters as the gyro for consistent timing of data availability
	int oversamplebits = SmartDashboard::GetNumber("OversampleBits",GYRO_OVERSAMPLEBITS);
	int avgbits = SmartDashboard::GetNumber("AvgBits",GYRO_SAMPLEAVGBITS);
	double samplerate = SmartDashboard::GetNumber("SampleRate",GYRO_SAMPLERATE);
	// Configure and initialize the thermostat
	MyThermostat->SetOversampleBits(oversamplebits);
	MyThermostat->SetAverageBits(avgbits);
	MyThermostat->SetSampleRate(samplerate);
	// There are no thermostat tuning parameters
	}
#endif


#ifdef MPU3050_GYRO
void NAVIGATOR :: InitMyThermostat()
	{
		// The temperature probe is built into the I2C gyro and was configured with the gyro.
	}
#endif


#ifdef ITG3200_GYRO
void NAVIGATOR :: InitMyThermostat()
	{
	thermo_sensitivity = (SmartDashboard::GetNumber("Thermo_sensitivity",GYRO_THERMO_SENSITIVITY) / 1000000000);
	GyroCenter_T = GYRO_THERMO_CENTER;
	SmartDashboard::PutNumber("Thermo_sensitivity",thermo_sensitivity * 1000000000);
	// The temperature probe is built into the I2C gyro and was configured with the gyro.
	}
#endif


#ifdef BUILTIN_ACCEL
void NAVIGATOR :: InitMyAccelerometer()
	{
//	MyAccel->SetRange(BuiltInAccelerometer::Accelerometer::kRange_2G);
	MyAccel->SetRange(BuiltInAccelerometer::kRange_2G);
	XaccelCenter = (SmartDashboard::GetNumber("XaccelCenter",ACCEL_XCENTER) / 1000);
	YaccelCenter = (SmartDashboard::GetNumber("YaccelCenter",ACCEL_YCENTER) / 1000);
	ZaccelCenter = (SmartDashboard::GetNumber("ZaccelCenter",ACCEL_ZCENTER) / 1000);
	Xsensitivity = SmartDashboard::GetNumber("Xsensitivity",ACCEL_XSENSITIVITY);
	Ysensitivity = SmartDashboard::GetNumber("Ysensitivity",ACCEL_YSENSITIVITY);
	FrictionEffect = SmartDashboard::GetNumber("FrictionEffect",ACCEL_FRICTION);
	SmartDashboard::PutNumber("XaccelCenter", XaccelCenter * 1000);
	SmartDashboard::PutNumber("YaccelCenter", YaccelCenter * 1000);
	SmartDashboard::PutNumber("ZaccelCenter", ZaccelCenter * 1000);
	SmartDashboard::PutNumber("Xsensitivity", Xsensitivity);
	SmartDashboard::PutNumber("Ysensitivity", Ysensitivity);
	SmartDashboard::PutNumber("FrictionEffect",FrictionEffect);
	}
#endif


#ifdef ADXL345_ACCEL
void NAVIGATOR :: InitMyAccelerometer()
	{
//	byte	bw_rate = 0;

	if (! MyAccel->AddressOnly()				// if the accelerometer is present, initialize its registers
			&& (! MyAccel->Write((uint8_t) ACCEL_PWR_CTL, (uint8_t) ACCEL_PWR_STANDBY)))
		{
		Wait (0.3);
		initcnt++;
		if (! MyAccel->Write((uint8_t) ACCEL_PWR_CTL, (uint8_t) ACCEL_PWR_MEASURE))
			{
			if ((! MyAccel->Write((uint8_t) ACCEL_BW_RATE, (uint8_t) ACCEL_RATE_50Hz))
				&& (! MyAccel->Write((uint8_t) ACCEL_INT_ENA, (uint8_t) ACCEL_DATA_RDY))
				&& (! MyAccel->Write((uint8_t) ACCEL_DATA_FMT, (uint8_t) (ACCEL_FULL_RES | ACCEL_2g))))
				//&& (! MyAccel->Write((uint8_t) ACCEL_DATA_FMT, (uint8_t) ACCEL_16g)))
				//&& (! MyAccel->Write((uint8_t) ACCEL_FIFO_CTL, (uint8_t) (ACCEL_FIFO_STREAM | ACCEL_FIFO_SAMPLES))))
				{
				initcnt++;
//				MyAccel->Read((uint8_t) ACCEL_BW_RATE, 1, &bw_rate);
//				SmartDashboard::PutNumber("ACCEL_BW_RATE", bw_rate & 0x1F);
				}
			}
		}
	XaccelCenter = (SmartDashboard::GetNumber("XaccelCenter",ACCEL_XCENTER) / 1000);
	YaccelCenter = (SmartDashboard::GetNumber("YaccelCenter",ACCEL_YCENTER) / 1000);
	ZaccelCenter = (SmartDashboard::GetNumber("ZaccelCenter",ACCEL_ZCENTER) / 1000);
	FrictionEffect = SmartDashboard::GetNumber("FrictionEffect",ACCEL_FRICTION);
	SmartDashboard::PutNumber("XaccelCenter", XaccelCenter * 1000);
	SmartDashboard::PutNumber("YaccelCenter", YaccelCenter * 1000);
	SmartDashboard::PutNumber("ZaccelCenter", ZaccelCenter * 1000);
	SmartDashboard::PutNumber("FrictionEffect",FrictionEffect);
	}
#endif


void NAVIGATOR :: Init(RobotStateBuffer *pRobotState)
	{
	initcnt++;
	Wait (1);		// had some problems with race condition initializing SmartDashboard and then
					// calling GetNumber too soon.  Fixed by waiting 1 second.
	SmartDashboard::PutNumber("NavInit", initcnt);
	pMyRobotState = pRobotState;
	pMyRobotState->Navigation_Position_X = 0;
	pMyRobotState->Navigation_Position_Y = 0;
	pMyRobotState->Navigation_Direction = 360;
	pMyRobotState->Navigation_Speed = 0;
	pMyRobotState->Navigation_Robot_Lost = false;
	NavTimer.Reset();
	InitMyGyro();
	InitMyThermostat();
	InitMyAccelerometer();
	NavTimer.Start();
	for (int i=1; (i < 200) && (fabs(NavTimer.Get()) < .000001); i++) Wait (.000001);  // wait for timer to start running

	INS_Calibrating = true;
	INS_semaphore = initializeMutexRecursive();
	//	here we will schedule the Gyro Data Collector interrupt service
	pReadSensors->StartPeriodic(SAMPLEPERIOD);
	//	here we will schedule the Robot Navigation Update interrupt service
	pINSupdate->StartPeriodic(INSUPDATEPERIOD);

	initcnt++;
	SmartDashboard::PutNumber("NavInit", initcnt);
	}



#ifdef ANALOG_GYRO
int NAVIGATOR :: ReadGyro()
	{
	gyro_accumulator_count = 1;
	MyGyro->GetAccumulatorOutput(&accumulator, &gyro_accumulator_count);
	gyro_accumulator_count -= prevcount;
	accumulator -= prevaccum;
	if (gyro_accumulator_count == 0)
		{
		// there is no new data available from the gyro
		// there are two ways to handle this
		//	1. don't record any sensor data points
		//		This means that the next sensor values will be counted for this cycle and the next
		//	2. just return the previous value.
		//		I like this option best because, if we get values from the accelerometer, we can
		//		apply them.  But, should we?
		// Actually, this should not be allowed to happen.  We should be configuring the sensors
		// for a samplerate that will guarantee at least one new value everytime we check.
		dataNotRdyCnt++;
		return 0;
		}
	z_spin_rate = (double) (((double) accumulator) / ((double) gyro_accumulator_count)) - GyroCenter_Z;

	// Now compensate for the temperature
	Sensitivity_Offset = 1 + ((GyroCenter_T - temperature) * thermo_sensitivity);
	z_spin_rate *= Sensitivity_Offset;

	if (z_spin_rate > 0)	// going clockwise
		{
		z_spin_rate = z_spin_rate * (cw_sensitivity + (z_spin_rate * SpinEffectCW));		// calculate z_spin_rate
		}
	else
		{
		z_spin_rate = z_spin_rate * (ccw_sensitivity + (z_spin_rate * SpinEffectCCW));	// calculate z_spin_rate
		}
	prevcount += gyro_accumulator_count;
	prevaccum += accumulator;
	return 1;	// using the fp accumulator, we will return 1 value per cycle
				// using an I2C gyro with FIFO, we might have multiple values queued up
	}
#endif


#ifdef WPILIB_GYRO
int NAVIGATOR :: ReadGyro()
	{
	gyro_accumulator_count = 1;
		z_spin_rate = (MyGyro->GetRate() - GyroCenter_Z);
	#endif
	#ifdef MPU3050_GYRO
		if ((MyGyro->Read(GYRO_Reg_IntSta, 1, gyro_rcv_buff)) || !(gyro_rcv_buff[0] & 0x01))
			{
			// new data is not yet available, we'll catch it next time around
			dataNotRdyCnt++;
			SmartDashboard::PutNumber("DataNotReady", dataNotRdyCnt);
			return;
			}
		if (! MyGyro->Read((uint8_t) GYRO_Reg_GyroZH, GYRO_READ_CNT, gyro_rcv_buff))
			{
			z_spin_rate = ((double)(((((int)accel_rcv_buff[1]) << 8) | ((int)gyro_rcv_buff[0]))) - GyroCenter_Z);
			}
	prevcount += gyro_accumulator_count;
	prevaccum += accumulator;
	return 1;	// using the fp accumulator, we will return 1 value per cycle
				// using an I2C gyro with FIFO, we might have multiple values queued up
	}
#endif


#ifdef MPU3050_GYRO
int NAVIGATOR :: ReadGyro()
	{
	if (INS_Calibrating)
		{
		if (fabs(z_spin_rate) > GyroNoiseLimit)
			{
			//	The robot got moved during the calibration sequence.
			noisyGyrocnt++;
			}
		GyroCenter_Z += (double) (10 * z_spin_rate / ((NavClockTime * 1000) + 10.0));		// adjust GyroCenter_Z by 0.1% with each pass
		}
	prevcount += gyro_accumulator_count;
	prevaccum += accumulator;
	return 1;	// using the fp accumulator, we will return 1 value per cycle
				// using an I2C gyro with FIFO, we might have multiple values queued up
	}
#endif


#ifdef ITG3200_GYRO
int NAVIGATOR :: ReadGyro()
	{
	byte	gyro_data_ready = 1;

	MyGyro->Read(GYRO_Reg_INT_STATUS, 3, gyro_rcv_buff); //read the interupt status to determine if new data is ready
	gyro_data_ready = gyro_rcv_buff[0] & GYRO_DataRdy;
	temperature = ((int) gyro_rcv_buff[1] << 24) | ((int) gyro_rcv_buff[2] << 16) >> 16;
	if (! gyro_data_ready)
		{
		// new data is not yet available, we'll catch it next time around and assume nothing bad happened
//		dataNotRdyCnt++;
//		SmartDashboard::PutNumber("DataNotReady", dataNotRdyCnt);
		return 0;
		}
	else
		{
		MyGyro->Read(GYRO_Reg_XOUT_H, GYRO_READ_CNT, gyro_rcv_buff);
		x_spin_rate = ((((int) gyro_rcv_buff[0] << 24) | ((int) gyro_rcv_buff[1] << 16)) >> 16) - GyroCenter_X;
		y_spin_rate = ((((int) gyro_rcv_buff[2] << 24) | ((int) gyro_rcv_buff[3] << 16)) >> 16) - GyroCenter_Y;
		z_spin_rate = ((((int) gyro_rcv_buff[4] << 24) | ((int) gyro_rcv_buff[5] << 16)) >> 16) - GyroCenter_Z;

		// Now compensate for the temperature
		Sensitivity_Offset = 1 + ((GyroCenter_T - temperature) * thermo_sensitivity);
		/* getting super-crazy value for temperature, so disabling thermo compensation for now.
		x_spin_rate *= Sensitivity_Offset;
		y_spin_rate *= Sensitivity_Offset;
		z_spin_rate *= Sensitivity_Offset;
//		SmartDashboard::PutNumber("ThermoComp", (Sensitivity_Offset - 1) * 1000);
//		SmartDashboard::PutNumber("Temperature", temperature);
		*/

		if ((z_spin_rate * cw_sensitivity) > 0)	// going clockwise
			{
			z_spin_rate = z_spin_rate * (cw_sensitivity + (z_spin_rate * SpinEffectCW));		// calculate z_spin_rate
			}
		else if ((z_spin_rate * cw_sensitivity) < 0)	// going counter-clockwise
			{
			z_spin_rate = z_spin_rate * (ccw_sensitivity + (z_spin_rate * SpinEffectCCW));	// calculate z_spin_rate
			}
		}
	return 1;
	}
#endif


int NAVIGATOR :: ReadThermostat()
	{
	#ifdef WPILIB_GYRO
		temperature = MyThermostat->GetValue();
	#endif
	#ifdef MPU3050_GYRO
		return 1;	// we only get one datapoint with each read
	#endif
	#ifdef ITG3200_GYRO
//		MyGyro->Read(GYRO_Reg_TEMP_OUT_H, 2, gyro_rcv_buff);
//		temperature = (((int) gyro_rcv_buff[0]) << 8) | ((int) gyro_rcv_buff[1]);
		return 1;	// we only get one datapoint with each read
	#endif
	#ifdef ANALOG_GYRO
		temperature = MyThermostat->GetValue() / pow(2,oversamplebits);
		GyroCenter_T += (double) (10 * (temperature - GyroCenter_T) / ((NavClockTime * 1000) + 10.0));		// adjust GyroCenter_T by 0.1% with each pass
		// probably want to divide the value by 2 ^ oversamplebits
		return 1;	// we only get one datapoint with each read
	#endif
	}


#ifdef ADXL345_ACCEL
int NAVIGATOR :: ReadAccel()
	{

	byte	accel_data_ready = 1;
//	byte	accel_fifo_queue_depth = 0;

	MyAccel->Read(ACCEL_INT_SRC, 1, accel_rcv_buff); //read the interupt status to determine if new data is ready
	accel_data_ready = accel_rcv_buff[0] & ACCEL_DATA_RDY;
	if (! accel_data_ready)
		{
		// new data is not yet available, we'll catch it next time around and assume nothing bad happened
		dataNotRdyCnt++;
//		SmartDashboard::PutNumber("DataNotReady", dataNotRdyCnt);
		}
//	MyAccel->Read(ACCEL_FIFO_STAT, 1, &accel_fifo_queue_depth); //read the acceleration data from the ADXL345
//	accel_fifo_queue_depth = (accel_fifo_queue_depth & ACCEL_FIFO_QUE_MSK) - 1;	// we may need to come get more readings

//	if (accel_fifo_queue_depth >= 0)	//note: FIFO data count not working.  So grab data even when count is 0
//	else
		{
//		if (accel_fifo_queue_depth > 0) SmartDashboard::PutNumber("AccelQcount",accel_fifo_queue_depth);
		MyAccel->Read(ACCEL_X0_DATA, ACCEL_READ_CNT, accel_rcv_buff);
		//read the acceleration data from the ADXL345
		// each axis reading comes in 2 bytes.  Least Significant Byte first!!
		// thus we are converting both bytes in to one short int

		/*
		 * Alternative mode is to use the FIFO queue on the chip.  One issue with this is
		 * if we are using an analog gyro, we only get one composite value each time we
		 * read the sensor inputs.  So, we would need to create a composite value from
		 * all entries in the FIFO queue.  For example, if there were 2 entries in the
		 * FIFO queue (a1 and a2), then the formula for the composite value would be
		 * a = (0.75 * a1) + (0.25 * a2).  I have not yet worked out the general formula
		 * for n entries in the queue.
		 *
		 * So, we are setting the accelerometer to sample at 1600Hz and queue the samples
		 * into a FIFO queue.  We will then read the data at 1ms intervals.  This will
		 * generally produce 2 samples per cycles, but occassionally only 1 sample.
		 * So, the max samples we will read per cycle is 2 and the formula above will
		 * appropriately average those samples.
		 */

		// Little endien (per documentation)
		x_accel = ((((int) accel_rcv_buff[1] << 24) | ((int) accel_rcv_buff[0] << 16)) >> 16) - XaccelCenter;
		y_accel = ((((int) accel_rcv_buff[3] << 24) | ((int) accel_rcv_buff[2] << 16)) >> 16) - YaccelCenter;
		z_accel = ((((int) accel_rcv_buff[5] << 24) | ((int) accel_rcv_buff[4] << 16)) >> 16) - ZaccelCenter;

		}
	return (int) accel_data_ready;	// if accel_fifo_queue_depth > 1, we will need to come get more readings
	}
#endif


#ifdef BUILTIN_ACCEL
int NAVIGATOR :: ReadAccel()
	{
	x_accel = MyAccel->GetX();// - XaccelCenter;
	y_accel = MyAccel->GetY() - YaccelCenter;
	z_accel = MyAccel->GetZ() - ZaccelCenter;

	if (fabs(x_accel - prevx) < 0.1) dataNotRdyCnt++;
	prevx = x_accel;
	x_accel -= XaccelCenter;


	return 1;
	}
#endif


void NAVIGATOR :: Push_Navigation_Data_Frame(double timestamp, double gyro_spin, double x_accel, double y_accel, double z_accel)
	{
	int queue_depth;
	CRITICAL_REGION(INS_semaphore)		// we need to reference values that are updated outside of this procedure
		{								// and we don't want those values getting changed while we are referencing them
		queue_depth = (NAVIGATION_QUEUE_SIZE + Navigation_Data_Queue_Top - Navigation_Data_Queue_Bottom) % NAVIGATION_QUEUE_SIZE;
		}
	END_REGION;
	if (queue_depth++ >= NAVIGATION_QUEUE_SIZE - 1)
		{
		// Queue is full and we are lost;
		// If in Autonomous, stop all motors
		pMyRobotState->Navigation_Robot_Lost = true;
		SmartDashboard::PutBoolean("NavOverflow",true);
		Wait(5);
		}
	else
		{
		if (Navigation_Data_Queue_Top++ >= NAVIGATION_QUEUE_SIZE - 1)
			{
			Synchronized sync(INS_semaphore);	// we are going to update values referenced by other procedure.
			Navigation_Data_Queue_Top = 0;
			}
		Navigation_Data_Queue[Navigation_Data_Queue_Top].timestamp = timestamp;
		Navigation_Data_Queue[Navigation_Data_Queue_Top].gyro_z = gyro_spin;
		Navigation_Data_Queue[Navigation_Data_Queue_Top].accel_x = x_accel;
		Navigation_Data_Queue[Navigation_Data_Queue_Top].accel_y = y_accel;
		Navigation_Data_Queue[Navigation_Data_Queue_Top].accel_z = z_accel;
			{
			Synchronized sync(INS_semaphore);	// we are going to update values referenced by other procedure.
			Navigation_Data_Queue_Depth++;
			}
		}
	}


void NAVIGATOR :: ReadSensors()
	{
	NavClockTime = NavTimer.Get();

	if (ReadGyro() + ReadThermostat() + ReadAccel() >= 0)
		{
		Push_Navigation_Data_Frame(NavClockTime, z_spin_rate, x_accel, y_accel, z_accel);
		}

	SampleRunTime = (NavTimer.Get() - NavClockTime) * 1000;	// exec time of this method in msec

	if (sample_counter++ % 20 == 0)
		{
//		SmartDashboard::PutNumber("NoisyGyroCount",noisyGyrocnt);
//		SmartDashboard::PutNumber("DataNotReady", dataNotRdyCnt);
		SmartDashboard::PutNumber("GyroCenter_Z", (GyroCenter_Z - GyroInitCenter));
		SmartDashboard::PutNumber("RawGyro", z_spin_rate);
//		SmartDashboard::PutBoolean("GyroCalibrating",INS_Calibrating);
		SmartDashboard::PutNumber("SampleLoopTime", (NavClockTime - SampleElapsedTime) * 50);
		SampleElapsedTime = NavClockTime;
//		SmartDashboard::PutNumber("AccumValue", accumulator);
//		SmartDashboard::PutNumber("AccumCount", gyro_accumulator_count);

		//double t = GyroCenter_T - (double) GYRO_THERMO_CENTER;
//		SmartDashboard::PutNumber("Temperature", GyroCenter_T);
//		SmartDashboard::PutNumber("Temperature", temperature);

//		SmartDashboard::PutNumber("X Axis", x_accel);
//		SmartDashboard::PutNumber("Y Axis", y_accel);
//		SmartDashboard::PutNumber("Z Axis", z_accel);
//		SmartDashboard::PutNumber("NoisyAccelCount",noisyAccelcnt);
//		SmartDashboard::PutNumber("XaccelCenter", XaccelCenter * 1000);
//		SmartDashboard::PutNumber("YaccelCenter", YaccelCenter * 1000);
//		SmartDashboard::PutNumber("ZaccelCenter", ZaccelCenter * 1000);
//		SmartDashboard::PutBoolean("AccelCalibrating",INS_Calibrating);
		}
	}


//  schedule this to run independently every 0.1 milliseconds
void NAVIGATOR :: CallReadSensors(void *controller)
	{
	NAVIGATOR *sample_sensors = (NAVIGATOR*) controller;
	sample_sensors->ReadSensors();
	}


void NAVIGATOR :: Zero()
	{
//	CalibrateGyro->Stop();				//	Stop the Cage scheduler;
	if (INS_Calibrating)
		{
		Synchronized sync(INS_semaphore);	// we are going to update values referenced by other procedure.
		INS_Calibrating = false;
//		NavTimer.Reset();					// either reset the NavTimer, or update the NavStartTime
		//NavStartTime = NavTimer.Get();	// I chose to reset the NavTimer, which keeps the math very simple
		GyroHeading = 0;			// This should be specified by the autonomous program selection
		Navigation_Data_Queue_Bottom = Navigation_Data_Queue_Top;  // Clear the data input queue
		Navigation_Status_Buffer.Xcoord = 0;			// This should be specified by the autonomous program selection
		Navigation_Status_Buffer.Ycoord = 0;			// This should be specified by the autonomous program selection
		Navigation_Status_Buffer.Xspeed = 0;
		Navigation_Status_Buffer.Yspeed = 0;
		Navigation_Status_Buffer.Xaccel = 0;
		Navigation_Status_Buffer.Yaccel = 0;
		Navigation_Status_Buffer.Timestamp = NavTimer.Get();
		Push_Navigation_Data_Frame(Navigation_Status_Buffer.Timestamp, z_spin_rate, x_accel, y_accel, z_accel);
		}
	}


bool NAVIGATOR :: Pop_Navigation_Data_Frame()
	{
	int queue_depth;
//	double noiselevelfilter = 25;
	CRITICAL_REGION(INS_semaphore)		// we need to reference values that are updated outside of this procedure
		{								// and we don't want those values getting changed while we are referencing them
		queue_depth = (NAVIGATION_QUEUE_SIZE + Navigation_Data_Queue_Top - Navigation_Data_Queue_Bottom) % NAVIGATION_QUEUE_SIZE;
		}
	END_REGION;
	if (queue_depth <= 1) return false;
	if (Navigation_Data_Queue_Bottom++ >= NAVIGATION_QUEUE_SIZE - 1)
		{
		Synchronized sync(INS_semaphore);	// we are going to update values referenced by other procedure.
		Navigation_Data_Queue_Bottom = 0;
		}
	NavElapsedTime = Navigation_Data_Queue[Navigation_Data_Queue_Bottom].timestamp;
//	NAVtemperature = Navigation_Data_Queue[Navigation_Data_Queue_Bottom].temperature;
	NAVz_spin = Navigation_Data_Queue[Navigation_Data_Queue_Bottom].gyro_z;
	NAVx_accel = (double) Navigation_Data_Queue[Navigation_Data_Queue_Bottom].accel_x;
	NAVy_accel = (double) Navigation_Data_Queue[Navigation_Data_Queue_Bottom].accel_y;
	NAVz_accel = (double) Navigation_Data_Queue[Navigation_Data_Queue_Bottom].accel_z;
		{
		Synchronized sync(INS_semaphore);	// we are going to update values referenced by other procedure.
		Navigation_Data_Queue_Depth--;
		}
	return true;
	}


void NAVIGATOR :: UpdateHeading()
	{
	// NAVspin is already compensated for temperature and converted to degrees, so just add it onto the GyroHeading
	GyroHeading += NAVz_spin;
	GyroHeading += GyroHeading > 360 ? -360 : GyroHeading < 0 ? 360 : 0;
	pMyRobotState->Navigation_Heading = GyroHeading;
	if (fabs(NAVz_spin) > GYRO_RATELIMIT)
		{
		pMyRobotState->Navigation_GyroTilt = true;
		}
	}


void NAVIGATOR :: UpdatePosition()
	{
	double TripTime = NavElapsedTime - Navigation_Status_Buffer.Timestamp;
	double T2 = pow(TripTime, 2);
	NAVx_accel *= Xsensitivity;
	NAVy_accel *= Ysensitivity;
	double ax1 = (NAVx_accel * sin((GyroHeading + 90) * PI / 180)) + (NAVy_accel * sin(GyroHeading * PI / 180));
	double ay1 = (NAVx_accel * cos((GyroHeading + 90) * PI / 180)) + (NAVy_accel * cos(GyroHeading * PI / 180));
	/*
	 * While the math appears to be correct, we have an issue in real life application.  It seems that
	 * once we start the robot moving in one direction at speed v = at and stop the robot with an accleration
	 * of v/t, the accelerometer is not reading a = v/t.  So the INS keeps going.  In fact, it keeps
	 * accelerating in the initial direction.  The theory is that the decleration caused by friction is
	 * sufficiently low to be lost in the noise.  So, we need to assume that the speed of the robot will
	 * decrease due to friction that is not registering on the accelerometer.  The actual friction value
	 * may depend not only on the drivetrain construction, but also on the direction of movement.
	 *
	 * We'll try a simple approach first.  We'll just reduce the robot's velocity along the field's x and y
	 * axses by a preset multiplier for each time interval.  If we need to, we'll a similar formula like the
	 * above to compute independent x and y friction deceleration effects based on GyroHeading.
	 */
	FrictionEffect = SmartDashboard::GetNumber("FrictionEffect",ACCEL_FRICTION);
	//	#define ACCEL_FRICTION 2.000	// percent of velocity loss due to friction
	Navigation_Status_Buffer.Xspeed *= ((100.000000 - FrictionEffect) / 100.000000);
	Navigation_Status_Buffer.Yspeed *= ((100.000000 - FrictionEffect) / 100.000000);

	// divide ax1 and ay1 by ZaccelCenter to convert ax1 and ay1 to Gs, then multiply by 981 cm/sec/sec/G
	// ZaccelCenter is presumably = 1g
	ax1 = ax1 * 981 / ZaccelCenter;
	ay1 = ay1 * 981 / ZaccelCenter;
	double ax = ax1;
	double ay = ay1;
	/*
	 * Now we assume that during the TripTime, our acceleration has changed from its old value to its new value
	 * along a linear progression curve (won't be totally true, but hopefully close enough).  So the actual
	 * acceleration factor that we want to apply is not ax1 and ay1, but rather something between ax1 and the
	 * prior_ax1 (Navigation_Status_Buffer.Xaccel); and also something between ay1 and the prior ay1
	 * (Navigation_Status_Buffer.Yaccel).  The formula is different depending on whether you are calculating
	 * the speed change or the distance change.
	 *
	 * First, we do the distance change.  Assume t1 = t2, and t1 + t2 = TripTime.
	 * ax = (0.75 * Navigation_Status_Buffer.Xaccel) + (0.25 * ax1).
	 * ay = (0.75 * Navigation_Status_Buffer.Yaccel) + (0.25 * ay1).
	 */
	if (true)
		{
		ax = (0.75 * Navigation_Status_Buffer.Xaccel) + (0.25 * ax1);
		ay = (0.75 * Navigation_Status_Buffer.Yaccel) + (0.25 * ay1);
		}
	Navigation_Status_Buffer.Xcoord += ((0.5 * ax * T2) + (Navigation_Status_Buffer.Xspeed * TripTime));
	Navigation_Status_Buffer.Ycoord += ((0.5 * ay * T2) + (Navigation_Status_Buffer.Yspeed * TripTime));
	/*
	 * the calculation for ax and ay is slightly different for speed.  It's a simple average.
	 */
	if (true)
		{
		ax = (0.5 * Navigation_Status_Buffer.Xaccel) + (0.5 * ax1);
		ay = (0.5 * Navigation_Status_Buffer.Yaccel) + (0.5 * ay1);
		}
//	if (INS_Calibrating)
//		{
//		Navigation_Status_Buffer.Xspeed = 0;
//		Navigation_Status_Buffer.Yspeed = 0;
//		XspeedCenter += (double) (10 * Navigation_Status_Buffer.Xspeed / ((NavClockTime * 1000) + 10.0));
//		YspeedCenter += (double) (10 * Navigation_Status_Buffer.Yspeed / ((NavClockTime * 1000) + 10.0));
//		}
//	else
//		{
		Navigation_Status_Buffer.Xspeed += (ax * TripTime);
		Navigation_Status_Buffer.Yspeed += (ay * TripTime);
//		}
	Navigation_Status_Buffer.Xaccel = ax1;
	Navigation_Status_Buffer.Yaccel = ay1;
	Navigation_Status_Buffer.Timestamp = NavElapsedTime;
	pMyRobotState->Navigation_Position_X = Navigation_Status_Buffer.Xcoord;
	pMyRobotState->Navigation_Position_Y = Navigation_Status_Buffer.Ycoord;
	RobotDirection = atan(Navigation_Status_Buffer.Xspeed / Navigation_Status_Buffer.Yspeed) * 180 / PI;
	RobotDirection += RobotDirection > 360 ? -360 : RobotDirection < 0 ? 360 : 0;
	pMyRobotState->Navigation_Direction = RobotDirection;
	pMyRobotState->Navigation_Speed = pow((pow(Navigation_Status_Buffer.Xspeed,2) + pow(Navigation_Status_Buffer.Yspeed,2)),0.5);
	}


// schedule this to run independently every 10 milliseconds
void NAVIGATOR :: UpdateINS()
	{
	while (Pop_Navigation_Data_Frame())
		{
		// Chop noise
		NAVx_accel *= (fabs(NAVx_accel) < ACCEL_NOISE_BASE) ? 0.05 : 1;
		NAVy_accel *= (fabs(NAVy_accel) < ACCEL_NOISE_BASE) ? 0.05 : 1;
		NAVz_accel *= (fabs(NAVz_accel) < ACCEL_NOISE_BASE) ? 0.05 : 1;
		NAVz_spin *= (fabs(NAVz_spin) < GYRO_NOISE_BASE) ? 0.25 : 1;


		if (INS_Calibrating)
			{
			if (fabs(NAVx_accel) + fabs(NAVy_accel) + fabs(NAVz_accel) > ACCEL_NOISELIMIT)
				{
				//	The robot got moved during the calibration sequence.
				noisyAccelcnt++;
				}
//			if (fmax(fmax(fabs(x_spin_rate),fabs(y_spin_rate)),fabs(z_spin_rate)) > GYRO_NOISELIMIT)
			if (fabs(NAVz_spin) > GYRO_NOISELIMIT)
				{
				//	The robot got moved during the calibration sequence.
				noisyGyrocnt++;
				}
			// Protected multi-thread accessed variable update
				{
				Synchronized sync(INS_semaphore);	// we are going to update values referenced by other procedure.
				XaccelCenter += (double) (10 * NAVx_accel / ((NavElapsedTime * 1000) + 10.0));
				YaccelCenter += (double) (10 * NAVy_accel / ((NavElapsedTime * 1000) + 10.0));
				ZaccelCenter += (double) (10 * NAVz_accel / ((NavElapsedTime * 1000) + 10.0));
				GyroCenter_T += (double) (10 * (temperature - GyroCenter_T) / ((NavClockTime * 1000) + 10.0));		// adjust GyroCenter_T by 0.1% with each pass
#ifndef ANALOG_GYRO
				GyroCenter_X += (double) (10 * x_spin_rate / ((NavClockTime * 1000) + 10.0));		// adjust GyroCenter_X by 0.1% with each pass
				GyroCenter_Y += (double) (10 * y_spin_rate / ((NavClockTime * 1000) + 10.0));		// adjust GyroCenter_Y by 0.1% with each pass
#endif
				GyroCenter_Z += (double) (10 * NAVz_spin / ((NavElapsedTime * 1000) + 10.0));		// adjust GyroCenter_Z by 0.1% with each pass
				Navigation_Data_Queue_Depth--;
				}
			}


//		SmartDashboard::PutNumber("RawGyro", NAVz_spin);

		UpdateHeading();
		UpdatePosition();
		if (NavLoopCnt++ % 10 == 0)		// update SmartDashboard every 10 loops
			{
//			SmartDashboard::PutNumber("GyroHeading", GyroHeading); // * NavElapsedTime / (double) NavLoopCnt);
			SmartDashboard::PutNumber("SampleRunTime", SampleRunTime);
//			SmartDashboard::PutNumber("NavElapsedTime", NavElapsedTime);
//			SmartDashboard::PutNumber("GyroHeading", pMyRobotState->Navigation_Heading);
//			SmartDashboard::PutNumber("Xcoord", pMyRobotState->Navigation_Position_X);
//			SmartDashboard::PutNumber("Ycoord", pMyRobotState->Navigation_Position_Y);
//			SmartDashboard::PutNumber("Direction", pMyRobotState->Navigation_Direction);
//			SmartDashboard::PutNumber("Speed", pMyRobotState->Navigation_Speed);
			}
		}
	}


//  schedule this to run independently every 10 milliseconds
void NAVIGATOR :: CallUpdateINS(void *controller)
	{
	NAVIGATOR *ins_update = (NAVIGATOR*) controller;
	ins_update->UpdateINS();
	}


